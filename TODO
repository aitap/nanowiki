+ refuse to start the server if DB versions mismatch but allow admincmds to run
 + die() cripples commands by crashing before them
  => check if $ARGV[0] is "admincmd" before die'ing
- refactor:
 ? 'parent' and 'title' regexps are still copypasted across code
- admincmds
 - dump into single HTML page (regenerated)
  - inter-page links will require special handling; hopefully The Link-Processing Regexp won't need to be copypasted
 + maintaindb: SQLite3 ANALYZE; VACUUM; fts4 'optimize';
- conflict detection: compare param("edit") (revision being edited) with mtime of last revision and suggest merging
 - this will require Algorithm::Diff and a new template
- employ FTS to search the wiki
 + this is definitely a major database schema upgrade
 - implementation:
  + CREATE VIRTUAL TABLE ftsindex USING fts4(content="pages",src,title,tokenize=unicode61)
	-- use external content because we still need the relationships of 'pages' table and don't want to store data twice
    -- full text searching by "who", "time" or "parent" is unlikely to be interesting and may clutter the index
	-- unicode61 to case fold all unicode characters, not just ASCII
  + CREATE TRIGGER pages_before_update BEFORE UPDATE ON pages BEGIN DELETE FROM ftsindex WHERE docid=old.rowid; end;
    CREATE TRIGGER pages_before_delete BEFORE DELETE ON pages BEGIN DELETE FROM ftsindex WHERE docid=old.rowid; end;
    CREATE TRIGGER pages_after_update AFTER UPDATE ON pages BEGIN INSERT INTO ftsindex(docid,src,title) VALUES(new.rowid,new.src,new.title); end;
    CREATE TRIGGER pages_after_insert AFTER INSERT ON pages BEGIN INSERT INTO ftsindex(docid,src,title) VALUES(new.rowid,new.src,new.title); end;
	-- triggers to work on index automatically - makes Perl side easier
  + SELECT snip, time, title FROM pages JOIN (SELECT docid AS idxid, snippet(ftsindex) AS snip FROM ftsindex WHERE src MATCH ?) ON pages.rowid = idxid;
    -- we can't MATCH a JOIN result, therefore we JOIN a MATCH result
   + implement rank() function for rank(matchinfo(ftsindex)) AS rkval and ORDER BY rkval DESC; see rankfunc at http://sqlite.org/fts3.html
  + searching across all revisions may look ugly, but otherwise revision history is severely crippled. What to do?
   fixed: only search across latest revisions. if something is OK to be searched for, it should be in the latest revision. if something was removed, it should not be found.
- normalize_path helper is still somewhat ugly => find a way to make sure path is normalized automatically
- use EXPLAIN QUERY PLAN to make sure indices are used in every search query
- CPANify
- app->config(defaults => ...) wastes 2048 bits of random data on every launch :(
