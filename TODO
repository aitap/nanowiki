- refactor:
 + split each controller into per-action ones (e.g. edit_form_controller vs. view_page_controller vs. view_history_controller)
  => ease adding new ones (search_controller)
 ? 'parent' and 'title' regexps are still copypasted across code
 - schema updates
  - employ pragma user_version to store schema version and write alter table commands to upgrade
  - add the primary key (title, time) to 'pages' table already
- admincmds
 - dump into single HTML page (regenerated)
  - inter-page links will require special handling; hopefully The Link-Processing Regexp won't need to be copypasted
 - maintaindb: SQLite3 ANALYZE; VACUUM; fts4 'optimize'; what else?
- conflict detection: compare param("edit") (revision being edited) with mtime of last revision and suggest merging
 - this will require Algorithm::Diff and a new template
- employ FTS to search the wiki
 - this is definitely a major database schema upgrade
 - implementation:
  - CREATE VIRTUAL TABLE ftsindex USING fts4(content="pages",src,title,tokenize=unicode61)
	-- use external content because we still need the relationships of 'pages' table and don't want to store data twice
    -- full text searching by "who", "time" or "parent" is unlikely to be interesting and may clutter the index
	-- unicode61 to case fold all unicode characters, not just ASCII
  - CREATE TRIGGER pages_before_update BEFORE UPDATE ON pages BEGIN DELETE FROM ftsindex WHERE docid=old.rowid; end;
    CREATE TRIGGER pages_before_delete BEFORE DELETE ON pages BEGIN DELETE FROM ftsindex WHERE docid=old.rowid; end;
    CREATE TRIGGER pages_after_update AFTER UPDATE ON pages BEGIN INSERT INTO ftsindex(docid,src,title) VALUES(new.rowid,new.src,new.title); end;
    CREATE TRIGGER pages_after_insert AFTER INSERT ON pages BEGIN INSERT INTO ftsindex(docid,src,title) VALUES(new.rowid,new.src,new.title); end;
	-- triggers to work on index automatically - makes Perl side easier
  - SELECT snip, time, title FROM pages JOIN (SELECT docid AS idxid, snippet(ftsindex) AS snip FROM ftsindex WHERE src MATCH ?) ON pages.rowid = idxid;
    -- we can't MATCH a JOIN result, therefore we JOIN a MATCH result
	-- TODO: implement rank() function for rank(matchinfo(ftsindex)) AS rkval and ORDER BY rkval DESC; see rankfunc at http://sqlite.org/fts3.html
- normalize_path helper is still somewhat ugly => find a way to make sure path is normalized automatically
- CPANify
- app->config(defaults => ...) wastes 2048 bits of random data on every launch :(
